C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: D:\00.SOFTWARE\03.KeilcC51\C51\BIN\C51.EXE ..\src\main.c LARGE OMF2 OPTIMIZE(7,SPEED) BROWSE INCDIR
                    -(..\Library\Device\Include;..\Library\StdDriver\inc;..\inc) DEFINE(CLOCK=4000000) DEBUG PRINT(.\lst\main.lst) TABS(2) OB
                    -JECT(.\Output\main.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* SPDX-License-Identifier: Apache-2.0                                                                    
             - */
   4          /* Copyright(c) 2020 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   5          /*                                                                                                        
             - */
   6          /*--------------------------------------------------------------------------------------------------------
             --*/
   7          
   8          
   9          #include "MS51_16K.H"
  10          #include "htim.h"
  11          #include "vcnl36821s.h"
  12          
  13          typedef enum
  14          {
  15            SYS_MODE_A = 0,
  16            SYS_MODE_B
  17          } _Sys_Mode;
  18          
  19          UINT8 LCD_CODE[] = {0x7E, 0x48, 0x3D, 0x6D, 0x4B, 0x67, 0x77, 0x4C, 0x7F, 0x6F, 0x5F, 0x00, 0x00, 0x00, 0x
             -00, 0x00};
  20          #define LCD_DOT 0x80
  21          
  22          #define LCD_PWM_ON P05 = 1
  23          #define LCD_PWM_OFF P05 = 0
  24          
  25          #define LCD_SCK_HIGH P04 = 1
  26          #define LCD_SCK_LOW P04 = 0
  27          
  28          #define LCD_LAT_HIGH P03 = 1
  29          #define LCD_LAT_LOW P03 = 0
  30          
  31          #define LCD_DATA P01
  32          #define LCD_DATA_HIGH P01 = 1
  33          #define LCD_DATA_LOW P01 = 0
  34          
  35          #define BUTTON_PRESSED !P07
  36          #define IS_SYS_RUN_MOD_A  P30
  37          #define TIMOUT_NON_DETECT_OBJ 1800000    //ms 
  38          
  39          UINT16 valueps;
  40          UINT16 obj_count = 0;
  41          UINT16 ss_read_fail = 0;
  42          
  43          UINT8 isCablibmode = 0;
  44          void LCD_show(UINT16 count);
  45          
  46          void system_shutdown(){
C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 2   

  47   1        VCNL36821_Stop();
  48   1        BOD_DISABLE;
  49   1        ALL_GPIO_INPUT_MODE;
  50   1        ENABLE_BIT7_FALLINGEDGE_TRIG;
  51   1        ENABLE_PIN_INTERRUPT;
  52   1        ENABLE_GLOBAL_INTERRUPT;
  53   1        while(1)
  54   1        {
  55   2          HAL_TIM_Pause();
  56   2          LCD_PWM_OFF;
  57   2          set_PCON_PD;
  58   2          HAL_TIM_run();
  59   2          HAL_Delay(150);
  60   2          if(BUTTON_PRESSED){   //debound buton
  61   3            while(BUTTON_PRESSED);
  62   3            break;
  63   3          }
  64   2        }
  65   1        set_SWRST;
  66   1        
  67   1      }
  68          void LCD_INIT()
  69          {
  70   1        // P05 LCD_PW out
  71   1        // P04 LCD_SCK out
  72   1        // P03 LCD_LAT out
  73   1        // P01 LCD_DATA out
  74   1        P0M1 &= 0xC5;  // 0b11000101;
  75   1        P0M2 |= ~0xC5; // 0b00111010;
  76   1        LCD_PWM_ON;
  77   1        LCD_SCK_LOW;
  78   1        LCD_LAT_LOW;
  79   1        LCD_DATA_LOW;
  80   1      }
  81          void LCD_Delay(UINT8 dl)
  82          {
  83   1        int i;
  84   1        for (i = 0; i < dl; i++)
  85   1        {
  86   2        }
  87   1      }
  88          
  89          void LCD_send_bytes(UINT8 *dt)
  90          {
  91   1        INT8 i, j;
  92   1        LCD_LAT_LOW;
  93   1        for (i = 2; i >= 0; i--)
  94   1        {
  95   2          for (j = 7; j >= 0; j--)
  96   2          {
  97   3            LCD_SCK_LOW;
  98   3            LCD_DATA = ((dt[i] >> j) & 0x01);
  99   3            LCD_Delay(5);
 100   3            LCD_SCK_HIGH;
 101   3            LCD_Delay(5);
 102   3          }
 103   2        }
 104   1        LCD_LAT_HIGH;
 105   1        LCD_Delay(10);
 106   1        LCD_LAT_LOW;
 107   1      }
 108          
C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 3   

 109          
 110          _Sys_Mode Sys_Mode = SYS_MODE_B;
 111          void LCD_show(UINT16 count)
 112          {
 113   1        UINT8 lcd_data[3];
 114   1        
 115   1        if(Sys_Mode == SYS_MODE_B) {
 116   2          count = (count % 1000);
 117   2          lcd_data[2] = LCD_CODE[count % 10];
 118   2          lcd_data[1] = LCD_CODE[(count / 10) % 10];
 119   2          lcd_data[0] = LCD_CODE[count / 100];
 120   2          
 121   2        } else if ( isCablibmode) {
 122   2          lcd_data[0] = LCD_CODE[8];
 123   2          lcd_data[1] = LCD_CODE[8]+ LCD_DOT;
 124   2          lcd_data[2] = LCD_CODE[8];
 125   2          
 126   2        } else {
 127   2          count = (count % 198);
 128   2          lcd_data[0] = LCD_CODE[(count + 1) / 20];
 129   2          lcd_data[1] = LCD_CODE[(((count + 1) / 2) % 10)] + LCD_DOT;
 130   2          lcd_data[2] = LCD_CODE[0];
 131   2          
 132   2          if (count)
 133   2          {
 134   3            lcd_data[2] = LCD_CODE[2];
 135   3            if (count % 2)
 136   3            {
 137   4              lcd_data[2] = LCD_CODE[1];
 138   4            }
 139   3          }
 140   2        }
 141   1        
 142   1        LCD_send_bytes(lcd_data);
 143   1        LCD_Delay(5);
 144   1        lcd_data[0] = lcd_data[1] = lcd_data[2] = 0x00;
 145   1        LCD_send_bytes(lcd_data);
 146   1        LCD_Delay(5);
 147   1      }
 148          
 149          
 150          
 151          UINT16 DETECT_THRESHOLD = 0;
 152          
 153          #define TIME_CHECK_OBJECT  300    //ms
 154          
 155          #define TIME_COUNT_OFFJECT 1500  //ms
 156          #define OBJECT_INC_TIMES  TIME_COUNT_OFFJECT/TIME_CHECK_OBJECT  
 157          
 158          #define TIME_COUNT_NON_OFFJECT 1500  //ms
 159          #define NON_DETECT_COUNT 5
 160          
 161          static UINT32 ttime = 0;
 162          static UINT8 error = 0;
 163          static UINT8 object_detected = 0;
 164          static UINT8 non_object_detected = NON_DETECT_COUNT;
 165          static UINT32 time_new_obj = 0xFFFFFFFF;
 166          
 167          void reset_counter(){
 168   1        ttime = HAL_GetTick() + 500;
 169   1        object_detected = 0;
 170   1        obj_count = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 4   

 171   1        time_new_obj = 0xFFFFFFFF;
 172   1      }
 173          
 174          void Process_VCNL36821S(void) {
 175   1            
 176   1          if(HAL_GetTick() > time_new_obj){
 177   2            if(obj_count) {
 178   3              obj_count --;
 179   3            }
 180   2            time_new_obj = 0xFFFFFFFF;
 181   2          }
 182   1        
 183   1          if (HAL_GetTick() > ttime){
 184   2            if(readWord(VCNL_PS_DATA,&valueps)) {
 185   3              ttime = HAL_GetTick() + TIME_CHECK_OBJECT;
 186   3              
 187   3              if(valueps > DETECT_THRESHOLD) {
 188   4                error = 0;
 189   4                object_detected ++;
 190   4                
 191   4                if(object_detected == OBJECT_INC_TIMES) {
 192   5                    obj_count ++;
 193   5                    if(obj_count %2) {   //end count is 1.1 2.1 3.1 ...
 194   6                      time_new_obj = HAL_GetTick() + 12000;
 195   6                    } else {
 196   6                      time_new_obj = 0xFFFFFFFF;
 197   6                    }
 198   5                }
 199   4                
 200   4                if(object_detected > OBJECT_INC_TIMES){
 201   5                  object_detected = OBJECT_INC_TIMES+1;
 202   5                }
 203   4              } else if(object_detected){
 204   4                  non_object_detected --;
 205   4                  if(!non_object_detected){
 206   5                    object_detected = 0;
 207   5                    non_object_detected = NON_DETECT_COUNT;
 208   5                  }
 209   4              }
 210   3            }
 211   2            else {
 212   3              ttime = HAL_GetTick() + 10;
 213   3              error++;
 214   3              if(error == 5){
 215   4                
 216   4              }
 217   3            }
 218   2          }
 219   1      }
 220          
 221          void GPIO_Init()
 222          {
 223   1        //P0.7 input
 224   1          P0M1 |= 0x80;
 225   1          P0M2 &= 0x7F;
 226   1      }
 227          typedef enum{
 228            BTN_IDLE  = 0,
 229            BTN_DEBOUND,
 230            BTN_CLICKED,
 231            BTN_PRESSED2S,
 232            BTN_PRESSED2_5S,
C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 5   

 233            BTN_PRESSED3S,
 234            BTN_RELEASE
 235          }_btn_state;
 236          
 237          void btn_time_click_callback()
 238          {
 239   1        if (Sys_Mode == SYS_MODE_A){
 240   2          reset_counter();
 241   2        }
 242   1      }
 243          void btn_time_2sec_callback()
 244          {
 245   1        if (Sys_Mode == SYS_MODE_B){
 246   2          reset_counter();
 247   2        }
 248   1      }
 249          void btn_time_2_5sec_callback()
 250          {
 251   1        if (Sys_Mode == SYS_MODE_A){
 252   2          system_shutdown();
 253   2        }
 254   1      }
 255          void btn_time_3sec_callback()
 256          {
 257   1        if (Sys_Mode == SYS_MODE_B){
 258   2          system_shutdown();
 259   2        }
 260   1      }
 261          static UINT32 last_btn_time = 0;
 262          void BTN_process()
 263          {
 264   1        static UINT32 btn_time = 0;
 265   1        
 266   1        static _btn_state btn_state= BTN_IDLE;
 267   1        if(BUTTON_PRESSED) {
 268   2          switch(btn_state) {
 269   3            case BTN_IDLE:
 270   3                btn_state = BTN_DEBOUND;
 271   3                btn_time = HAL_GetTick() +25;
 272   3              break;
 273   3            case BTN_DEBOUND:
 274   3              if(HAL_GetTick() >btn_time){
 275   4                  btn_state = BTN_PRESSED2S;
 276   4      //            btn_time_click_callback();
 277   4                  btn_time = HAL_GetTick() +2000 ;
 278   4              }
 279   3              break;
 280   3            case BTN_PRESSED2S:
 281   3              if(HAL_GetTick() >btn_time){
 282   4                  btn_time_2sec_callback();
 283   4                  btn_state = BTN_PRESSED2_5S;
 284   4                  btn_time = HAL_GetTick() +500 ;
 285   4              }
 286   3              break;
 287   3            case BTN_PRESSED2_5S:
 288   3              if(HAL_GetTick() >btn_time){
 289   4                  btn_time_2_5sec_callback();
 290   4                  btn_state = BTN_PRESSED3S;
 291   4                  btn_time = HAL_GetTick() +500 ;
 292   4              }
 293   3              break;
 294   3            case BTN_PRESSED3S:
C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 6   

 295   3              if(HAL_GetTick() >btn_time){
 296   4                btn_time_3sec_callback();
 297   4              }
 298   3              break;
 299   3            case BTN_RELEASE:
 300   3              {
 301   4                
 302   4              }
 303   3              break;
 304   3            default:
 305   3              break;
 306   3          }
 307   2        } else {
 308   2          switch(btn_state)
 309   2          {
 310   3            case BTN_PRESSED2_5S:
 311   3            case BTN_PRESSED2S:
 312   3              if (Sys_Mode == SYS_MODE_B){
 313   4                obj_count ++;
 314   4              } else if (Sys_Mode == SYS_MODE_A){
 315   4      //          if(HAL_GetTick() < last_btn_time)
 316   4      //          {
 317   4      //            isCablibmode = 1- isCablibmode;
 318   4      //          }
 319   4      //          last_btn_time = HAL_GetTick()+500;
 320   4                reset_counter();
 321   4              } 
 322   3              break;
 323   3          }
 324   2          btn_state = BTN_IDLE;
 325   2        }
 326   1      }
 327          
 328          void PinInterrupt_ISR (void) interrupt 7 
 329          {
 330   1        _push_(SFRS);
 331   1        
 332   1          SFRS = 0;
 333   1          switch(PIF)
 334   1          {
 335   2          case (SET_BIT7):{
 336   3                PIF&=CLR_BIT7; 
 337   3                break;
 338   3          } 
 339   2          default: break;
 340   2          }
 341   1      
 342   1        _pop_(SFRS);
 343   1      }
 344          
 345          void check_non_obj_detect_timout(void)
 346          {
 347   1        static UINT16 old_obj_count = 0xFFFF; // dif obj_count
 348   1        static xdata UINT32 timout =0;
 349   1        if(old_obj_count != obj_count)
 350   1        {
 351   2          timout = HAL_GetTick() + TIMOUT_NON_DETECT_OBJ;
 352   2          old_obj_count =obj_count;
 353   2        }
 354   1        if(HAL_GetTick() > timout)
 355   1        {
 356   2          system_shutdown();
C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 7   

 357   2        }
 358   1        
 359   1      }
 360          
 361          _Sys_Mode Check_system_mode()
 362          {
 363   1        if(IS_SYS_RUN_MOD_A)
 364   1        {
 365   2          return SYS_MODE_A;
 366   2        } 
 367   1        return SYS_MODE_B;
 368   1      }
 369          
 370          void WDT_ISR (void)   interrupt 10
 371          {
 372   1      _push_(SFRS);
 373   1      
 374   1        /* Config Enable WDT reset and not clear couter trig reset */
 375   1          WDT_COUNTER_CLEAR;                     /* Clear WDT counter */
 376   1          while(!(WDCON&=SET_BIT6));             /* Check for the WDT counter cleared */
 377   1          P12 = ~P12;
 378   1      
 379   1          CLEAR_WDT_INTERRUPT_FLAG;
 380   1      _pop_(SFRS);
 381   1      }
 382          
 383          
 384          void Disable_WDT_Reset_Config(void)
 385          {
 386   1        UINT8 cf0,cf1,cf2,cf3,cf4;
 387   1        
 388   1          set_CHPCON_IAPEN;
 389   1          IAPAL = 0x00;
 390   1          IAPAH = 0x00;
 391   1          IAPCN = BYTE_READ_CONFIG;
 392   1          set_IAPTRG_IAPGO;                                  //Storage CONFIG0 data
 393   1          cf0 = IAPFD;
 394   1          IAPAL = 0x01;
 395   1          set_IAPTRG_IAPGO;                                  //Storage CONFIG1 data
 396   1          cf1 = IAPFD;
 397   1          IAPAL = 0x02;
 398   1          set_IAPTRG_IAPGO;                                  //Storage CONFIG2 data
 399   1          cf2 = IAPFD;
 400   1          IAPAL = 0x03;
 401   1          set_IAPTRG_IAPGO;                                  //Storage CONFIG3 data
 402   1          cf3 = IAPFD;
 403   1          IAPAL = 0x04;
 404   1          set_IAPTRG_IAPGO;                                  //Storage CONFIG4 data
 405   1          cf4 = IAPFD;
 406   1          cf4 |= 0xF0;                                      //Moidfy Storage CONFIG4 data disable WDT reset
 407   1          
 408   1          set_IAPUEN_CFUEN;  
 409   1          IAPCN = PAGE_ERASE_CONFIG;                        //Erase CONFIG all
 410   1          IAPAH = 0x00;
 411   1          IAPAL = 0x00;
 412   1          IAPFD = 0xFF;
 413   1          set_IAPTRG_IAPGO;
 414   1          
 415   1          IAPCN = BYTE_PROGRAM_CONFIG;                    //Write CONFIG
 416   1          IAPFD = cf0;
 417   1          set_IAPTRG_IAPGO;
 418   1          IAPAL = 0x01;
C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 8   

 419   1          IAPFD = cf1;
 420   1          set_IAPTRG_IAPGO;
 421   1          IAPAL = 0x02;
 422   1          IAPFD = cf2;
 423   1          set_IAPTRG_IAPGO;
 424   1          IAPAL = 0x03;
 425   1          IAPFD = cf3;
 426   1          set_IAPTRG_IAPGO;
 427   1          IAPAL = 0x04;
 428   1          IAPFD = cf4;
 429   1          set_IAPTRG_IAPGO;
 430   1      
 431   1          set_IAPUEN_CFUEN;
 432   1          clr_CHPCON_IAPEN;
 433   1          if (WDCON&SET_BIT3)
 434   1          {
 435   2            clr_WDCON_WDTRF;
 436   2            set_CHPCON_SWRST;
 437   2          }
 438   1      }
 439          
 440          
 441          void main(void)
 442          {
 443   1        UINT16 id = 0;
 444   1        UINT32 ttime = 0;
 445   1        
 446   1        UINT32 Timm_tmp = 0;
 447   1        UINT8 count_val = 0;
 448   1        UINT32 total=0;
 449   1        
 450   1        UINT32 Timm = 0;
 451   1      
 452   1        
 453   1        ALL_GPIO_INPUT_MODE;
 454   1        MODIFY_HIRC(HIRC_16);
 455   1        /* Initial I2C function */
 456   1        CKDIV = 4;    //2Mhz 16/(CKDIV*2) 
 457   1        GPIO_Init();
 458   1        Sys_Mode = Check_system_mode();
 459   1        Init_I2C();
 460   1        LCD_INIT();
 461   1        Timer3_INT_Initial(DIV2, 0xFC, 0x18);
 462   1        if (Sys_Mode == SYS_MODE_A){
 463   2          VCNL_initialize();
 464   2          isCablibmode = 1;
 465   2          total = 0;
 466   2          Timm = HAL_GetTick() + 1000;
 467   2          readWord(VCNL_PS_ID,&valueps);
 468   2          while(1)
 469   2          {
 470   3            if(HAL_GetTick() > Timm)
 471   3            {
 472   4              if(HAL_GetTick() > Timm_tmp) {
 473   5                if(readWord(VCNL_PS_DATA,&valueps))
 474   5                {
 475   6                  ss_read_fail = 0;
 476   6                  Timm_tmp = HAL_GetTick() + 200;
 477   6                  total += valueps;
 478   6                  count_val ++;
 479   6                  if(valueps > DETECT_THRESHOLD)
 480   6                  {
C51 COMPILER V9.60.7.0   MAIN                                                              09/16/2023 11:09:30 PAGE 9   

 481   7                    DETECT_THRESHOLD = valueps;
 482   7                  }
 483   6                  if(count_val == 15)
 484   6                    break;
 485   6                } else {
 486   6                  Timm_tmp = HAL_GetTick() + 30;
 487   6                  ss_read_fail++;
 488   6                }
 489   5              }
 490   4            }
 491   3            LCD_show(valueps);
 492   3          }
 493   2          //DETECT_THRESHOLD = (total / 30) + 15;
 494   2          DETECT_THRESHOLD = DETECT_THRESHOLD+2;
 495   2          isCablibmode=0;
 496   2        } else {
 497   2          VCNL36821_Stop();
 498   2        }
 499   1        while (1)
 500   1        {
 501   2      //    WDT_COUNTER_CLEAR;                     /* Clear WDT counter */
 502   2          BTN_process();
 503   2      //    I2C_reset();
 504   2          if (Sys_Mode == SYS_MODE_A){
 505   3            Process_VCNL36821S();
 506   3            
 507   3          }
 508   2          if(Sys_Mode != Check_system_mode())
 509   2          {
 510   3            set_SWRST;
 511   3          }
 512   2          if(isCablibmode) {
 513   3            LCD_show(valueps);
 514   3          } else {
 515   3            LCD_show(obj_count);
 516   3          }
 517   2          check_non_obj_detect_timout();
 518   2        }
 519   1        /* =================== */
 520   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2368    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     52      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
